/// \page analysis NA62Analysis/Tutorial
///	<b>Table of content</b>	
///	<ul>
///		<li>\ref requirements
///		<li>\ref Installation
///		<li>\ref rebuild
///		<li>\ref update
///		<li>\ref QuickStart
///		<li>\ref Troubleshooting
///	</ul>
///
///	\section requirements Requirements 
/// This framework need Geant4, ROOT and NA62MC to be compiled and has been tested with the following versions :<br>
/// <ul>
/// 	<li>gcc 4.6.3 | 4.1.2
/// 	<li>Geant4.9.5p03
/// 	<li>ROOT 5.34.04 | 5.34.05
/// 	<li>NA62MC rev_245, rev_255, rev_263
/// </ul>
/// Take care of compiling each of these with the same version of gcc.
/// Although only tested with these versions, it's most likely to work without problem on any other versions
/// 
/// Before starting to work with the framework, you should set the NA62MCSOURCE environment variable to point to the directory where you keep your sources of NA62MC. 
/// 
/// \section glossary Glossary
/// NA62Analysis is divided into two distinct directory trees
/// <ul>
/// 	<li><b>[FWDir]</b> Framework directory: Contains NA62Analysis itself (what you get from svn). You should never have the need to work in this directory.
/// 	<li><b>[UserDir]</b> User directory: Work directory that contains your own work (your analyzers, configurations, executables, ...)
/// </ul>
/// 
/// \section Installation Installation
/// <ul>
/// 	<li>Extract the sources from the svn repository<br>
/// 		\code svn co svn co svn+ssh://svn.cern.ch/reps/na62fw/trunk/NA62Analysis\endcode
/// 	<li>Make sure the <b>NA62MCSOURCE</b> environment variable points to the directory containing <b>NA62MC</b>
/// 	<li>Setup the environment<br>
/// 		\code source scripts/env.[c]sh\endcode
/// 	<li>Prepare your user directory<b>[UserDir]</b> by issuing<br>
/// 		\code./NA62AnalysisBuilder.py prepare PathToUserDir\endcode
/// 		Your user directory<b>[UserDir]</b> can be anywhere except in the same directory than this framework. It should ideally be 
/// 		kept separate to avoid overwriting any of your work when updating the framework. If any update is needed inside your
/// 		user directory, the NA62AnalysisBuilder.py tool will take care of it automatically.
/// 	<li>Go inside your user directory<b>[UserDir]</b>, check that scripts/env.[c]sh is correct.
/// 	<li>The framework is now installed. After sourcing the scripts/env.[c]sh script the framework directory<b>[FWDir]</b> is added to the <b>PATH</b>.<br> 
/// 		You should be able to run the framework from your user directory<b>[UserDir]</b> without ever going back to the framework directory. 
/// 		All the python scripts are also directly available from your user directory<b>[FWDir]</b>.
/// </ul>
/// 
/// \section rebuild Clean rebuild	
/// If you change NA62MC or NA62Reconstruction, you should rebuild the framework.
/// <ul>
/// 	<li> Go in your user directory<b>[UserDir]</b> and setup the environment
/// 		\code source scripts/env.[c]sh\endcode
/// 	<li>Clean the current build
/// 		\code NA62AnalysisBuilder.py cleanAll\endcode
/// 	<li>The libraries will be recompiled next time you will try to build and executable with
/// 		\code NA62AnalysisBuilder.py configFileName\endcode
/// </ul>
/// 
/// \section update Update
/// To update the framework, just go inside the framework directory<b>[FWDir]</b> and issue
/// \code svn update\endcode
/// The next time you try to build an executable with
/// \code NA62AnalysisBuilder.py build configFileName\endcode
/// the libraries will be recompiled and eventual changes in your user directory<b>[UserDir]</b> will be safely done automatically.
/// In case of problem you will see a warning message and inform you on the appropriate actions to manually solve the problem.
/// In case of compilation problem you can try a complete clean rebuild of the framework. See \ref rebuild
/// 
/// \section QuickStart QuickStart
/// 
/// <ul>
/// 	<li>NA62AnalysisBuilder.py help				: will print the help of the NA62AnalysisBuilder.py script
/// 	<li>NA62AnalysisBuilder.py available			: will print the list of available Analyzers
/// 	<li>NA62AnalysisBuilder.py cleanUser	 		: will remove all files generated by the build in the user directory<b>[UserDir]</b>
/// 	<li>NA62AnalysisBuilder.py cleanFW	 		: will remove all files generated by the build in the FW directory[FWDir]
/// 	<li>NA62AnalysisBuilder.py cleanAll	 		: will remove all files generated by the build in the FW directory<b>[FWDir]</b> and user directory<b>[UserDir]</b>
/// 	<li>NA62AnalysisBuilder.py new AnalyzerName		: will create a new analyzer with name AnalyzerName in the user directory<b>[UserDir]</b><br>
///			Alternatively AnalyzerName can be replaced by the following syntax:<br> 
///        		\code AnalyzerName(InputType TreeName, ...)\endcode
///        	This will already include the correct persistency headers, request the input tree and retrieve the input events.<br>
///        	Example: Creating an analyzer named toto using as input the GigaTracker MonteCarlo and LKr and Spectrometer RECO<br>
///        		\code NA62AnalysisBuilder.py new "toto(MC GigaTracker, Reco LKr, Reco Spectrometer)"\endcode
/// 	<li>NA62AnalysisBuilder.py rename oldName newName	: will rename a user analyzer
/// 	<li>NA62AnalysisBuilder.py build configFileName		: will build the FW using the configuration file configFileName
/// 	<li>NA62AnalysisBuilder.py prepare path			: will prepare a user directory at the specified path
///		<li>NA62AnalysisBuilder.py examples			: will build the libraries for examples and import the configuration files in user directory<b>[UserDir]</b>
/// </ul>
/// The prepare and build commands have some flags that can be used to enable some features:
/// <ul>
/// 	<li>-d/--debug : activate the debug flag -g in the compiler for producing debugging information
/// 	<li>--no-c++11 : disable c++11 support in the framework. C++11 support is automatically enabled for compiler supporting the feature.
/// 	<li>--full-warning : activate all the warning flags during compilation
/// 	<li>-j/--jobs : number of processors to use while building (make -j option)
/// </ul>
/// To get help from the script: 
/// \code NA62AnalysisBuilder.py -h \endcode 
/// Or for help on a specific command: 
/// \code NA62AnalysisBuilder.py commandName -h \endcode 
/// 
/// If you want to write a new analyzer on MC simulation or reconstruction coming from NA62MC or NA62Analysis:
/// <ol>
///	<li> Go in your user directory<b>[UserDir]</b> and setup the environment<br>
/// 		\code source scripts/env.[c]sh\endcode
/// 	<li> Create a new analyzer with<br>
/// 		\code NA62AnalysisBuilder.py new analyzer-Name\endcode
/// 	<li> Write your analyzer. The header and source files are
/// 		\code
/// PathToUserDir/Analyzer/include/analyzer-Name.hh
/// PathToUserDir/Analyzer/src/analyzer-Name.cc \endcode
///          In <b>[UserDir]</b> there is also a preformatted runtime configuration file
/// </ol>
/// 
/// If you want to run the program with a set of analyzers
/// <ol>
/// 	<li> Go in you user directory (PathToUserDir) and setup the environment<br>
/// 		\code source scripts/env.[c]sh\endcode
/// 	<li> Create a config file containing the following line:<br>
/// 		\code
/// exec = name-Of-Executable-To-Generate
/// analyzers = List-Of-Analyzers-You-Want-To-Run-Separated-By-White-Spaces
/// libs = List-Of-Additional-Libraries-To-Link-With
/// libsdirs = List-Of-Additional-Directories-To-Search-For-Libraries
/// incdirs = List-Of-Additional-Directories-To-Search-For-Include-Files
/// 		\endcode
///			If one of the analyzers specified in the list does not exist, a prompt will propose you to create it. For this reason, the syntax<br> 
///      	\code AnalyzerName(InputType TreeName, ...)\endcode
///			is valid in the config file as well.
/// 	<li> Compile in the user directory with <br>
/// 		\code NA62AnalysisBuilder.py build configFileName\endcode
/// 	<li> Run with <br>
/// 	\code 
/// ./yourExecutableName (-i path | -l/--list path) [options]
/// 
/// Allowed options:
///   -h/--help				: Display this help
///   -v [level]			: Verbosity level.
/// 						  Possible values: kNo, kUser, kNormal, kDebug or 0,1,2,3;
///							  Default=kNo; If level not specified: kNormal
///   -g					: Graphical mode. Starts a ROOT application for display.
/// 						  Do not automatically exit at the end of the processing, Ctrl-C to exit.
///   -n/--nevt int			: Maximum number of events to process.
///   -o/--output path		: Path to output ROOT file. Will be overwritten if already exists.
///   -p/--params string	: List of parameters to pass to analyzers.
/// 						  The format of the string is 
/// 						  "analyzerName:param=val;param=val&analyzerName:param=val&..."
///   --histo				: Read histograms only and bypass TTree reading.
///   --start int			: Index of the first event to process.
/// 						  Event index starts at 0.
///   --config path			: Path to a configuration file containing analyzers parameters.
///   --reffile path		: Path to a ROOT file containing reference plots.
///   --ignore				: Ignore non-existing trees and continue processing.
/// 
/// Mutually exclusive options groups:
///  Group1:
///   -i path				: Path to an input ROOT file.
///  Group2:
///   -l/--list path		: Path to a text file containing a list of paths to input ROOT files.
/// 						  One file per line.
///   -B/--nfiles int		: Maximum number of files to process from the list.
/// 
/// 	\endcode
/// </ol>
/// 
/// The runtime configuration file will advantageously replace long list of command line parameters 
/// (with -p). The format of the configuration file is the following:<br> 
/// 
/// \code
/// [[analyzer-Name]]
/// Parameter1 = value1
/// Parameter2 = value2
/// 
/// [[analyzer-Name2]]
/// ...
/// ...
/// ...
/// \endcode
///
/// The following parameters exist by default for all analyzers:
/// <ul>
/// 	<li><b>Verbose</b> (default=kNo, possible kNo, kUser, kNormal, kDebug)
/// 	<li><b>AutoUpdate</b> (takes a list of plots names. They will be drawn on screen during processing and refreshed at regular interval)
/// 	<li><b>UpdateInterval</b> (default=10, refresh interval for AutoUpdate plots in number of events)
/// </ul>
///
/// \section HistoRun Running with histograms input instead of TTrees
/// It is possible to run an Analyzer on input histograms only. To do so, create an Analyzer as usual.<br>
/// You can use the method
/// \code
/// UserMethods::RequestHistogram("ROOT directory name", "histogram name", appendOnNewFile)
/// \endcode
/// to request an histogram from the input files. If appendOnNewFile is true, every time a new file is opened the histogram is
/// fetched from the file and appended to the current histogram. At the end of the processing, the histogram would then be the sum
/// of all the histograms in the input files. If appendOnNewFile is false the current histogram is always replaced with the more 
/// recent one fetched from the file.<br>
/// Calling RequestHistogram should be done in the InitHist method or later. If the histogram is found the method returns a
/// pointer to it. You can either save the pointer in a member variable of your analyzer or retrieve it later with 
/// \code
/// UserMethods::GetInputHistogram("ROOT directory name", "histogram name")
/// \endcode
/// Note that both methods return a TH1* pointer. It is your responsibility to cast it into the correct histogram type
/// (TH1I*, TH1D*, ..., TH2I*, TH2D*, ...).<br>
/// There are two possible ways to analyze input histograms. 
/// <ul>
/// 	<li> Running NA62Analysis the usual way. The requested TTrees are read and for each event the Process method is called. Every time
/// 		 a new file is opened, the Analyzer::StartOfBurst() method is called, notifying the Analyzer that a new file has been
/// 		 opened and therefore that a new histogram has been read.
/// 	<li> Running NA62Analysis with the --histo option. This will prevent the framework to read the input TTrees, reading only the
/// 		 histograms from the input files. The same notification mechanism as above applies. However the notion of event is modified
/// 		 and instead of calling the Analyzer::Process method for each event, the method is called once for each input file.<br>
/// 		 If you try to access any TTree related information in this mode, a warning message is printed. Also a NULL pointer is returned
/// 		 instead of the requested information. It is always your responsibility to test the return value of methods and not try to access
/// 		 them if NULL.
/// </ul>
/// 
/// \section Troubleshooting Troubleshooting
///
/// <ul>
/// 	<li>If you are experiencing strange problems with compilation and linking, first try a <br>
/// 		\code NA62AnalysisBuilder.py cleanAll\endcode
///			before trying to recompile the framework. Problems sometimes happens after changing version of ROOT, NA62MC, ... or when some framework libraries were not recompiled 
///			automatically after modifications in the code. 
/// </ul>
///